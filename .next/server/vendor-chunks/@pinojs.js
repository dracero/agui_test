"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@pinojs";
exports.ids = ["vendor-chunks/@pinojs"];
exports.modules = {

/***/ "(rsc)/./node_modules/@pinojs/redact/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@pinojs/redact/index.js ***!
  \**********************************************/
/***/ ((module) => {

eval("\n\nfunction deepClone (obj) {\n  if (obj === null || typeof obj !== 'object') {\n    return obj\n  }\n\n  if (obj instanceof Date) {\n    return new Date(obj.getTime())\n  }\n\n  if (obj instanceof Array) {\n    const cloned = []\n    for (let i = 0; i < obj.length; i++) {\n      cloned[i] = deepClone(obj[i])\n    }\n    return cloned\n  }\n\n  if (typeof obj === 'object') {\n    const cloned = Object.create(Object.getPrototypeOf(obj))\n    for (const key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        cloned[key] = deepClone(obj[key])\n      }\n    }\n    return cloned\n  }\n\n  return obj\n}\n\nfunction parsePath (path) {\n  const parts = []\n  let current = ''\n  let inBrackets = false\n  let inQuotes = false\n  let quoteChar = ''\n\n  for (let i = 0; i < path.length; i++) {\n    const char = path[i]\n\n    if (!inBrackets && char === '.') {\n      if (current) {\n        parts.push(current)\n        current = ''\n      }\n    } else if (char === '[') {\n      if (current) {\n        parts.push(current)\n        current = ''\n      }\n      inBrackets = true\n    } else if (char === ']' && inBrackets) {\n      // Always push the current value when closing brackets, even if it's an empty string\n      parts.push(current)\n      current = ''\n      inBrackets = false\n      inQuotes = false\n    } else if ((char === '\"' || char === \"'\") && inBrackets) {\n      if (!inQuotes) {\n        inQuotes = true\n        quoteChar = char\n      } else if (char === quoteChar) {\n        inQuotes = false\n        quoteChar = ''\n      } else {\n        current += char\n      }\n    } else {\n      current += char\n    }\n  }\n\n  if (current) {\n    parts.push(current)\n  }\n\n  return parts\n}\n\nfunction setValue (obj, parts, value) {\n  let current = obj\n\n  for (let i = 0; i < parts.length - 1; i++) {\n    const key = parts[i]\n    // Type safety: Check if current is an object before using 'in' operator\n    if (typeof current !== 'object' || current === null || !(key in current)) {\n      return false // Path doesn't exist, don't create it\n    }\n    if (typeof current[key] !== 'object' || current[key] === null) {\n      return false // Path doesn't exist properly\n    }\n    current = current[key]\n  }\n\n  const lastKey = parts[parts.length - 1]\n  if (lastKey === '*') {\n    if (Array.isArray(current)) {\n      for (let i = 0; i < current.length; i++) {\n        current[i] = value\n      }\n    } else if (typeof current === 'object' && current !== null) {\n      for (const key in current) {\n        if (Object.prototype.hasOwnProperty.call(current, key)) {\n          current[key] = value\n        }\n      }\n    }\n  } else {\n    // Type safety: Check if current is an object before using 'in' operator\n    if (typeof current === 'object' && current !== null && lastKey in current && Object.prototype.hasOwnProperty.call(current, lastKey)) {\n      current[lastKey] = value\n    }\n  }\n  return true\n}\n\nfunction removeKey (obj, parts) {\n  let current = obj\n\n  for (let i = 0; i < parts.length - 1; i++) {\n    const key = parts[i]\n    // Type safety: Check if current is an object before using 'in' operator\n    if (typeof current !== 'object' || current === null || !(key in current)) {\n      return false // Path doesn't exist, don't create it\n    }\n    if (typeof current[key] !== 'object' || current[key] === null) {\n      return false // Path doesn't exist properly\n    }\n    current = current[key]\n  }\n\n  const lastKey = parts[parts.length - 1]\n  if (lastKey === '*') {\n    if (Array.isArray(current)) {\n      // For arrays, we can't really \"remove\" all items as that would change indices\n      // Instead, we set them to undefined which will be omitted by JSON.stringify\n      for (let i = 0; i < current.length; i++) {\n        current[i] = undefined\n      }\n    } else if (typeof current === 'object' && current !== null) {\n      for (const key in current) {\n        if (Object.prototype.hasOwnProperty.call(current, key)) {\n          delete current[key]\n        }\n      }\n    }\n  } else {\n    // Type safety: Check if current is an object before using 'in' operator\n    if (typeof current === 'object' && current !== null && lastKey in current && Object.prototype.hasOwnProperty.call(current, lastKey)) {\n      delete current[lastKey]\n    }\n  }\n  return true\n}\n\n// Sentinel object to distinguish between undefined value and non-existent path\nconst PATH_NOT_FOUND = Symbol('PATH_NOT_FOUND')\n\nfunction getValueIfExists (obj, parts) {\n  let current = obj\n\n  for (const part of parts) {\n    if (current === null || current === undefined) {\n      return PATH_NOT_FOUND\n    }\n    // Type safety: Check if current is an object before property access\n    if (typeof current !== 'object' || current === null) {\n      return PATH_NOT_FOUND\n    }\n    // Check if the property exists before accessing it\n    if (!(part in current)) {\n      return PATH_NOT_FOUND\n    }\n    current = current[part]\n  }\n\n  return current\n}\n\nfunction getValue (obj, parts) {\n  let current = obj\n\n  for (const part of parts) {\n    if (current === null || current === undefined) {\n      return undefined\n    }\n    // Type safety: Check if current is an object before property access\n    if (typeof current !== 'object' || current === null) {\n      return undefined\n    }\n    current = current[part]\n  }\n\n  return current\n}\n\nfunction redactPaths (obj, paths, censor, remove = false) {\n  for (const path of paths) {\n    const parts = parsePath(path)\n\n    if (parts.includes('*')) {\n      redactWildcardPath(obj, parts, censor, path, remove)\n    } else {\n      if (remove) {\n        removeKey(obj, parts)\n      } else {\n        // Get value only if path exists - single traversal\n        const value = getValueIfExists(obj, parts)\n        if (value === PATH_NOT_FOUND) {\n          continue\n        }\n\n        const actualCensor = typeof censor === 'function'\n          ? censor(value, parts)\n          : censor\n        setValue(obj, parts, actualCensor)\n      }\n    }\n  }\n}\n\nfunction redactWildcardPath (obj, parts, censor, originalPath, remove = false) {\n  const wildcardIndex = parts.indexOf('*')\n\n  if (wildcardIndex === parts.length - 1) {\n    const parentParts = parts.slice(0, -1)\n    let current = obj\n\n    for (const part of parentParts) {\n      if (current === null || current === undefined) return\n      // Type safety: Check if current is an object before property access\n      if (typeof current !== 'object' || current === null) return\n      current = current[part]\n    }\n\n    if (Array.isArray(current)) {\n      if (remove) {\n        // For arrays, set all items to undefined which will be omitted by JSON.stringify\n        for (let i = 0; i < current.length; i++) {\n          current[i] = undefined\n        }\n      } else {\n        for (let i = 0; i < current.length; i++) {\n          const indexPath = [...parentParts, i.toString()]\n          const actualCensor = typeof censor === 'function'\n            ? censor(current[i], indexPath)\n            : censor\n          current[i] = actualCensor\n        }\n      }\n    } else if (typeof current === 'object' && current !== null) {\n      if (remove) {\n        // Collect keys to delete to avoid issues with deleting during iteration\n        const keysToDelete = []\n        for (const key in current) {\n          if (Object.prototype.hasOwnProperty.call(current, key)) {\n            keysToDelete.push(key)\n          }\n        }\n        for (const key of keysToDelete) {\n          delete current[key]\n        }\n      } else {\n        for (const key in current) {\n          const keyPath = [...parentParts, key]\n          const actualCensor = typeof censor === 'function'\n            ? censor(current[key], keyPath)\n            : censor\n          current[key] = actualCensor\n        }\n      }\n    }\n  } else {\n    redactIntermediateWildcard(obj, parts, censor, wildcardIndex, originalPath, remove)\n  }\n}\n\nfunction redactIntermediateWildcard (obj, parts, censor, wildcardIndex, originalPath, remove = false) {\n  const beforeWildcard = parts.slice(0, wildcardIndex)\n  const afterWildcard = parts.slice(wildcardIndex + 1)\n  const pathArray = [] // Cached array to avoid allocations\n\n  function traverse (current, pathLength) {\n    if (pathLength === beforeWildcard.length) {\n      if (Array.isArray(current)) {\n        for (let i = 0; i < current.length; i++) {\n          pathArray[pathLength] = i.toString()\n          traverse(current[i], pathLength + 1)\n        }\n      } else if (typeof current === 'object' && current !== null) {\n        for (const key in current) {\n          pathArray[pathLength] = key\n          traverse(current[key], pathLength + 1)\n        }\n      }\n    } else if (pathLength < beforeWildcard.length) {\n      const nextKey = beforeWildcard[pathLength]\n      // Type safety: Check if current is an object before using 'in' operator\n      if (current && typeof current === 'object' && current !== null && nextKey in current) {\n        pathArray[pathLength] = nextKey\n        traverse(current[nextKey], pathLength + 1)\n      }\n    } else {\n      // Check if afterWildcard contains more wildcards\n      if (afterWildcard.includes('*')) {\n        // Recursively handle remaining wildcards\n        // Wrap censor to prepend current path context\n        const wrappedCensor = typeof censor === 'function'\n          ? (value, path) => {\n              const fullPath = [...pathArray.slice(0, pathLength), ...path]\n              return censor(value, fullPath)\n            }\n          : censor\n        redactWildcardPath(current, afterWildcard, wrappedCensor, originalPath, remove)\n      } else {\n        // No more wildcards, apply the redaction directly\n        if (remove) {\n          removeKey(current, afterWildcard)\n        } else {\n          const actualCensor = typeof censor === 'function'\n            ? censor(getValue(current, afterWildcard), [...pathArray.slice(0, pathLength), ...afterWildcard])\n            : censor\n          setValue(current, afterWildcard, actualCensor)\n        }\n      }\n    }\n  }\n\n  if (beforeWildcard.length === 0) {\n    traverse(obj, 0)\n  } else {\n    let current = obj\n    for (let i = 0; i < beforeWildcard.length; i++) {\n      const part = beforeWildcard[i]\n      if (current === null || current === undefined) return\n      // Type safety: Check if current is an object before property access\n      if (typeof current !== 'object' || current === null) return\n      current = current[part]\n      pathArray[i] = part\n    }\n    if (current !== null && current !== undefined) {\n      traverse(current, beforeWildcard.length)\n    }\n  }\n}\n\nfunction buildPathStructure (pathsToClone) {\n  if (pathsToClone.length === 0) {\n    return null // No paths to redact\n  }\n\n  // Parse all paths and organize by depth\n  const pathStructure = new Map()\n  for (const path of pathsToClone) {\n    const parts = parsePath(path)\n    let current = pathStructure\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i]\n      if (!current.has(part)) {\n        current.set(part, new Map())\n      }\n      current = current.get(part)\n    }\n  }\n  return pathStructure\n}\n\nfunction selectiveClone (obj, pathStructure) {\n  if (!pathStructure) {\n    return obj // No paths to redact, return original\n  }\n\n  function cloneSelectively (source, pathMap, depth = 0) {\n    if (!pathMap || pathMap.size === 0) {\n      return source // No more paths to clone, return reference\n    }\n\n    if (source === null || typeof source !== 'object') {\n      return source\n    }\n\n    if (source instanceof Date) {\n      return new Date(source.getTime())\n    }\n\n    if (Array.isArray(source)) {\n      const cloned = []\n      for (let i = 0; i < source.length; i++) {\n        const indexStr = i.toString()\n        if (pathMap.has(indexStr) || pathMap.has('*')) {\n          cloned[i] = cloneSelectively(source[i], pathMap.get(indexStr) || pathMap.get('*'))\n        } else {\n          cloned[i] = source[i] // Share reference for non-redacted items\n        }\n      }\n      return cloned\n    }\n\n    // Handle objects\n    const cloned = Object.create(Object.getPrototypeOf(source))\n    for (const key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        if (pathMap.has(key) || pathMap.has('*')) {\n          cloned[key] = cloneSelectively(source[key], pathMap.get(key) || pathMap.get('*'))\n        } else {\n          cloned[key] = source[key] // Share reference for non-redacted properties\n        }\n      }\n    }\n    return cloned\n  }\n\n  return cloneSelectively(obj, pathStructure)\n}\n\nfunction validatePath (path) {\n  if (typeof path !== 'string') {\n    throw new Error('Paths must be (non-empty) strings')\n  }\n\n  if (path === '') {\n    throw new Error('Invalid redaction path ()')\n  }\n\n  // Check for double dots\n  if (path.includes('..')) {\n    throw new Error(`Invalid redaction path (${path})`)\n  }\n\n  // Check for comma-separated paths (invalid syntax)\n  if (path.includes(',')) {\n    throw new Error(`Invalid redaction path (${path})`)\n  }\n\n  // Check for unmatched brackets\n  let bracketCount = 0\n  let inQuotes = false\n  let quoteChar = ''\n\n  for (let i = 0; i < path.length; i++) {\n    const char = path[i]\n\n    if ((char === '\"' || char === \"'\") && bracketCount > 0) {\n      if (!inQuotes) {\n        inQuotes = true\n        quoteChar = char\n      } else if (char === quoteChar) {\n        inQuotes = false\n        quoteChar = ''\n      }\n    } else if (char === '[' && !inQuotes) {\n      bracketCount++\n    } else if (char === ']' && !inQuotes) {\n      bracketCount--\n      if (bracketCount < 0) {\n        throw new Error(`Invalid redaction path (${path})`)\n      }\n    }\n  }\n\n  if (bracketCount !== 0) {\n    throw new Error(`Invalid redaction path (${path})`)\n  }\n}\n\nfunction validatePaths (paths) {\n  if (!Array.isArray(paths)) {\n    throw new TypeError('paths must be an array')\n  }\n\n  for (const path of paths) {\n    validatePath(path)\n  }\n}\n\nfunction slowRedact (options = {}) {\n  const {\n    paths = [],\n    censor = '[REDACTED]',\n    serialize = JSON.stringify,\n    strict = true,\n    remove = false\n  } = options\n\n  // Validate paths upfront to match fast-redact behavior\n  validatePaths(paths)\n\n  // Build path structure once during setup, not on every call\n  const pathStructure = buildPathStructure(paths)\n\n  return function redact (obj) {\n    if (strict && (obj === null || typeof obj !== 'object')) {\n      if (obj === null || obj === undefined) {\n        return serialize ? serialize(obj) : obj\n      }\n      if (typeof obj !== 'object') {\n        return serialize ? serialize(obj) : obj\n      }\n    }\n\n    // Only clone paths that need redaction\n    const cloned = selectiveClone(obj, pathStructure)\n    const original = obj // Keep reference to original for restore\n\n    let actualCensor = censor\n    if (typeof censor === 'function') {\n      actualCensor = censor\n    }\n\n    redactPaths(cloned, paths, actualCensor, remove)\n\n    if (serialize === false) {\n      cloned.restore = function () {\n        return deepClone(original) // Full clone only when restore is called\n      }\n      return cloned\n    }\n\n    if (typeof serialize === 'function') {\n      return serialize(cloned)\n    }\n\n    return JSON.stringify(cloned)\n  }\n}\n\nmodule.exports = slowRedact\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBpbm9qcy9yZWRhY3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0EsUUFBUTtBQUNSLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxLQUFLO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsS0FBSztBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsbURBQW1ELEtBQUs7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLEtBQUs7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL2hvbWUvY2V0ZWMvTm9kZVByb2plY3RzL2FndWlfdGVzdC9ub2RlX21vZHVsZXMvQHBpbm9qcy9yZWRhY3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmZ1bmN0aW9uIGRlZXBDbG9uZSAob2JqKSB7XG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb2JqXG4gIH1cblxuICBpZiAob2JqIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShvYmouZ2V0VGltZSgpKVxuICB9XG5cbiAgaWYgKG9iaiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgY29uc3QgY2xvbmVkID0gW11cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgY2xvbmVkW2ldID0gZGVlcENsb25lKG9ialtpXSlcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lZFxuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3QgY2xvbmVkID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSlcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgIGNsb25lZFtrZXldID0gZGVlcENsb25lKG9ialtrZXldKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xvbmVkXG4gIH1cblxuICByZXR1cm4gb2JqXG59XG5cbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBjb25zdCBwYXJ0cyA9IFtdXG4gIGxldCBjdXJyZW50ID0gJydcbiAgbGV0IGluQnJhY2tldHMgPSBmYWxzZVxuICBsZXQgaW5RdW90ZXMgPSBmYWxzZVxuICBsZXQgcXVvdGVDaGFyID0gJydcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gcGF0aFtpXVxuXG4gICAgaWYgKCFpbkJyYWNrZXRzICYmIGNoYXIgPT09ICcuJykge1xuICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgcGFydHMucHVzaChjdXJyZW50KVxuICAgICAgICBjdXJyZW50ID0gJydcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICdbJykge1xuICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgcGFydHMucHVzaChjdXJyZW50KVxuICAgICAgICBjdXJyZW50ID0gJydcbiAgICAgIH1cbiAgICAgIGluQnJhY2tldHMgPSB0cnVlXG4gICAgfSBlbHNlIGlmIChjaGFyID09PSAnXScgJiYgaW5CcmFja2V0cykge1xuICAgICAgLy8gQWx3YXlzIHB1c2ggdGhlIGN1cnJlbnQgdmFsdWUgd2hlbiBjbG9zaW5nIGJyYWNrZXRzLCBldmVuIGlmIGl0J3MgYW4gZW1wdHkgc3RyaW5nXG4gICAgICBwYXJ0cy5wdXNoKGN1cnJlbnQpXG4gICAgICBjdXJyZW50ID0gJydcbiAgICAgIGluQnJhY2tldHMgPSBmYWxzZVxuICAgICAgaW5RdW90ZXMgPSBmYWxzZVxuICAgIH0gZWxzZSBpZiAoKGNoYXIgPT09ICdcIicgfHwgY2hhciA9PT0gXCInXCIpICYmIGluQnJhY2tldHMpIHtcbiAgICAgIGlmICghaW5RdW90ZXMpIHtcbiAgICAgICAgaW5RdW90ZXMgPSB0cnVlXG4gICAgICAgIHF1b3RlQ2hhciA9IGNoYXJcbiAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gcXVvdGVDaGFyKSB7XG4gICAgICAgIGluUXVvdGVzID0gZmFsc2VcbiAgICAgICAgcXVvdGVDaGFyID0gJydcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnQgKz0gY2hhclxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50ICs9IGNoYXJcbiAgICB9XG4gIH1cblxuICBpZiAoY3VycmVudCkge1xuICAgIHBhcnRzLnB1c2goY3VycmVudClcbiAgfVxuXG4gIHJldHVybiBwYXJ0c1xufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZSAob2JqLCBwYXJ0cywgdmFsdWUpIHtcbiAgbGV0IGN1cnJlbnQgPSBvYmpcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IHBhcnRzW2ldXG4gICAgLy8gVHlwZSBzYWZldHk6IENoZWNrIGlmIGN1cnJlbnQgaXMgYW4gb2JqZWN0IGJlZm9yZSB1c2luZyAnaW4nIG9wZXJhdG9yXG4gICAgaWYgKHR5cGVvZiBjdXJyZW50ICE9PSAnb2JqZWN0JyB8fCBjdXJyZW50ID09PSBudWxsIHx8ICEoa2V5IGluIGN1cnJlbnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2UgLy8gUGF0aCBkb2Vzbid0IGV4aXN0LCBkb24ndCBjcmVhdGUgaXRcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjdXJyZW50W2tleV0gIT09ICdvYmplY3QnIHx8IGN1cnJlbnRba2V5XSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlIC8vIFBhdGggZG9lc24ndCBleGlzdCBwcm9wZXJseVxuICAgIH1cbiAgICBjdXJyZW50ID0gY3VycmVudFtrZXldXG4gIH1cblxuICBjb25zdCBsYXN0S2V5ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV1cbiAgaWYgKGxhc3RLZXkgPT09ICcqJykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3VycmVudFtpXSA9IHZhbHVlXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY3VycmVudCA9PT0gJ29iamVjdCcgJiYgY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3VycmVudCkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGN1cnJlbnQsIGtleSkpIHtcbiAgICAgICAgICBjdXJyZW50W2tleV0gPSB2YWx1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFR5cGUgc2FmZXR5OiBDaGVjayBpZiBjdXJyZW50IGlzIGFuIG9iamVjdCBiZWZvcmUgdXNpbmcgJ2luJyBvcGVyYXRvclxuICAgIGlmICh0eXBlb2YgY3VycmVudCA9PT0gJ29iamVjdCcgJiYgY3VycmVudCAhPT0gbnVsbCAmJiBsYXN0S2V5IGluIGN1cnJlbnQgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGN1cnJlbnQsIGxhc3RLZXkpKSB7XG4gICAgICBjdXJyZW50W2xhc3RLZXldID0gdmFsdWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gcmVtb3ZlS2V5IChvYmosIHBhcnRzKSB7XG4gIGxldCBjdXJyZW50ID0gb2JqXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBwYXJ0c1tpXVxuICAgIC8vIFR5cGUgc2FmZXR5OiBDaGVjayBpZiBjdXJyZW50IGlzIGFuIG9iamVjdCBiZWZvcmUgdXNpbmcgJ2luJyBvcGVyYXRvclxuICAgIGlmICh0eXBlb2YgY3VycmVudCAhPT0gJ29iamVjdCcgfHwgY3VycmVudCA9PT0gbnVsbCB8fCAhKGtleSBpbiBjdXJyZW50KSkge1xuICAgICAgcmV0dXJuIGZhbHNlIC8vIFBhdGggZG9lc24ndCBleGlzdCwgZG9uJ3QgY3JlYXRlIGl0XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY3VycmVudFtrZXldICE9PSAnb2JqZWN0JyB8fCBjdXJyZW50W2tleV0gPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZSAvLyBQYXRoIGRvZXNuJ3QgZXhpc3QgcHJvcGVybHlcbiAgICB9XG4gICAgY3VycmVudCA9IGN1cnJlbnRba2V5XVxuICB9XG5cbiAgY29uc3QgbGFzdEtleSA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdXG4gIGlmIChsYXN0S2V5ID09PSAnKicpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50KSkge1xuICAgICAgLy8gRm9yIGFycmF5cywgd2UgY2FuJ3QgcmVhbGx5IFwicmVtb3ZlXCIgYWxsIGl0ZW1zIGFzIHRoYXQgd291bGQgY2hhbmdlIGluZGljZXNcbiAgICAgIC8vIEluc3RlYWQsIHdlIHNldCB0aGVtIHRvIHVuZGVmaW5lZCB3aGljaCB3aWxsIGJlIG9taXR0ZWQgYnkgSlNPTi5zdHJpbmdpZnlcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjdXJyZW50W2ldID0gdW5kZWZpbmVkXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY3VycmVudCA9PT0gJ29iamVjdCcgJiYgY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3VycmVudCkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGN1cnJlbnQsIGtleSkpIHtcbiAgICAgICAgICBkZWxldGUgY3VycmVudFtrZXldXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVHlwZSBzYWZldHk6IENoZWNrIGlmIGN1cnJlbnQgaXMgYW4gb2JqZWN0IGJlZm9yZSB1c2luZyAnaW4nIG9wZXJhdG9yXG4gICAgaWYgKHR5cGVvZiBjdXJyZW50ID09PSAnb2JqZWN0JyAmJiBjdXJyZW50ICE9PSBudWxsICYmIGxhc3RLZXkgaW4gY3VycmVudCAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY3VycmVudCwgbGFzdEtleSkpIHtcbiAgICAgIGRlbGV0ZSBjdXJyZW50W2xhc3RLZXldXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8vIFNlbnRpbmVsIG9iamVjdCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIHVuZGVmaW5lZCB2YWx1ZSBhbmQgbm9uLWV4aXN0ZW50IHBhdGhcbmNvbnN0IFBBVEhfTk9UX0ZPVU5EID0gU3ltYm9sKCdQQVRIX05PVF9GT1VORCcpXG5cbmZ1bmN0aW9uIGdldFZhbHVlSWZFeGlzdHMgKG9iaiwgcGFydHMpIHtcbiAgbGV0IGN1cnJlbnQgPSBvYmpcblxuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBQQVRIX05PVF9GT1VORFxuICAgIH1cbiAgICAvLyBUeXBlIHNhZmV0eTogQ2hlY2sgaWYgY3VycmVudCBpcyBhbiBvYmplY3QgYmVmb3JlIHByb3BlcnR5IGFjY2Vzc1xuICAgIGlmICh0eXBlb2YgY3VycmVudCAhPT0gJ29iamVjdCcgfHwgY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFBBVEhfTk9UX0ZPVU5EXG4gICAgfVxuICAgIC8vIENoZWNrIGlmIHRoZSBwcm9wZXJ0eSBleGlzdHMgYmVmb3JlIGFjY2Vzc2luZyBpdFxuICAgIGlmICghKHBhcnQgaW4gY3VycmVudCkpIHtcbiAgICAgIHJldHVybiBQQVRIX05PVF9GT1VORFxuICAgIH1cbiAgICBjdXJyZW50ID0gY3VycmVudFtwYXJ0XVxuICB9XG5cbiAgcmV0dXJuIGN1cnJlbnRcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9iaiwgcGFydHMpIHtcbiAgbGV0IGN1cnJlbnQgPSBvYmpcblxuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gICAgLy8gVHlwZSBzYWZldHk6IENoZWNrIGlmIGN1cnJlbnQgaXMgYW4gb2JqZWN0IGJlZm9yZSBwcm9wZXJ0eSBhY2Nlc3NcbiAgICBpZiAodHlwZW9mIGN1cnJlbnQgIT09ICdvYmplY3QnIHx8IGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gICAgY3VycmVudCA9IGN1cnJlbnRbcGFydF1cbiAgfVxuXG4gIHJldHVybiBjdXJyZW50XG59XG5cbmZ1bmN0aW9uIHJlZGFjdFBhdGhzIChvYmosIHBhdGhzLCBjZW5zb3IsIHJlbW92ZSA9IGZhbHNlKSB7XG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIGNvbnN0IHBhcnRzID0gcGFyc2VQYXRoKHBhdGgpXG5cbiAgICBpZiAocGFydHMuaW5jbHVkZXMoJyonKSkge1xuICAgICAgcmVkYWN0V2lsZGNhcmRQYXRoKG9iaiwgcGFydHMsIGNlbnNvciwgcGF0aCwgcmVtb3ZlKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgIHJlbW92ZUtleShvYmosIHBhcnRzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gR2V0IHZhbHVlIG9ubHkgaWYgcGF0aCBleGlzdHMgLSBzaW5nbGUgdHJhdmVyc2FsXG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0VmFsdWVJZkV4aXN0cyhvYmosIHBhcnRzKVxuICAgICAgICBpZiAodmFsdWUgPT09IFBBVEhfTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFjdHVhbENlbnNvciA9IHR5cGVvZiBjZW5zb3IgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICA/IGNlbnNvcih2YWx1ZSwgcGFydHMpXG4gICAgICAgICAgOiBjZW5zb3JcbiAgICAgICAgc2V0VmFsdWUob2JqLCBwYXJ0cywgYWN0dWFsQ2Vuc29yKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZWRhY3RXaWxkY2FyZFBhdGggKG9iaiwgcGFydHMsIGNlbnNvciwgb3JpZ2luYWxQYXRoLCByZW1vdmUgPSBmYWxzZSkge1xuICBjb25zdCB3aWxkY2FyZEluZGV4ID0gcGFydHMuaW5kZXhPZignKicpXG5cbiAgaWYgKHdpbGRjYXJkSW5kZXggPT09IHBhcnRzLmxlbmd0aCAtIDEpIHtcbiAgICBjb25zdCBwYXJlbnRQYXJ0cyA9IHBhcnRzLnNsaWNlKDAsIC0xKVxuICAgIGxldCBjdXJyZW50ID0gb2JqXG5cbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFyZW50UGFydHMpIHtcbiAgICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQgPT09IHVuZGVmaW5lZCkgcmV0dXJuXG4gICAgICAvLyBUeXBlIHNhZmV0eTogQ2hlY2sgaWYgY3VycmVudCBpcyBhbiBvYmplY3QgYmVmb3JlIHByb3BlcnR5IGFjY2Vzc1xuICAgICAgaWYgKHR5cGVvZiBjdXJyZW50ICE9PSAnb2JqZWN0JyB8fCBjdXJyZW50ID09PSBudWxsKSByZXR1cm5cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50W3BhcnRdXG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgLy8gRm9yIGFycmF5cywgc2V0IGFsbCBpdGVtcyB0byB1bmRlZmluZWQgd2hpY2ggd2lsbCBiZSBvbWl0dGVkIGJ5IEpTT04uc3RyaW5naWZ5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGN1cnJlbnRbaV0gPSB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgaW5kZXhQYXRoID0gWy4uLnBhcmVudFBhcnRzLCBpLnRvU3RyaW5nKCldXG4gICAgICAgICAgY29uc3QgYWN0dWFsQ2Vuc29yID0gdHlwZW9mIGNlbnNvciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBjZW5zb3IoY3VycmVudFtpXSwgaW5kZXhQYXRoKVxuICAgICAgICAgICAgOiBjZW5zb3JcbiAgICAgICAgICBjdXJyZW50W2ldID0gYWN0dWFsQ2Vuc29yXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjdXJyZW50ID09PSAnb2JqZWN0JyAmJiBjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgIC8vIENvbGxlY3Qga2V5cyB0byBkZWxldGUgdG8gYXZvaWQgaXNzdWVzIHdpdGggZGVsZXRpbmcgZHVyaW5nIGl0ZXJhdGlvblxuICAgICAgICBjb25zdCBrZXlzVG9EZWxldGUgPSBbXVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdXJyZW50KSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjdXJyZW50LCBrZXkpKSB7XG4gICAgICAgICAgICBrZXlzVG9EZWxldGUucHVzaChrZXkpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXNUb0RlbGV0ZSkge1xuICAgICAgICAgIGRlbGV0ZSBjdXJyZW50W2tleV1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3VycmVudCkge1xuICAgICAgICAgIGNvbnN0IGtleVBhdGggPSBbLi4ucGFyZW50UGFydHMsIGtleV1cbiAgICAgICAgICBjb25zdCBhY3R1YWxDZW5zb3IgPSB0eXBlb2YgY2Vuc29yID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGNlbnNvcihjdXJyZW50W2tleV0sIGtleVBhdGgpXG4gICAgICAgICAgICA6IGNlbnNvclxuICAgICAgICAgIGN1cnJlbnRba2V5XSA9IGFjdHVhbENlbnNvclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlZGFjdEludGVybWVkaWF0ZVdpbGRjYXJkKG9iaiwgcGFydHMsIGNlbnNvciwgd2lsZGNhcmRJbmRleCwgb3JpZ2luYWxQYXRoLCByZW1vdmUpXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVkYWN0SW50ZXJtZWRpYXRlV2lsZGNhcmQgKG9iaiwgcGFydHMsIGNlbnNvciwgd2lsZGNhcmRJbmRleCwgb3JpZ2luYWxQYXRoLCByZW1vdmUgPSBmYWxzZSkge1xuICBjb25zdCBiZWZvcmVXaWxkY2FyZCA9IHBhcnRzLnNsaWNlKDAsIHdpbGRjYXJkSW5kZXgpXG4gIGNvbnN0IGFmdGVyV2lsZGNhcmQgPSBwYXJ0cy5zbGljZSh3aWxkY2FyZEluZGV4ICsgMSlcbiAgY29uc3QgcGF0aEFycmF5ID0gW10gLy8gQ2FjaGVkIGFycmF5IHRvIGF2b2lkIGFsbG9jYXRpb25zXG5cbiAgZnVuY3Rpb24gdHJhdmVyc2UgKGN1cnJlbnQsIHBhdGhMZW5ndGgpIHtcbiAgICBpZiAocGF0aExlbmd0aCA9PT0gYmVmb3JlV2lsZGNhcmQubGVuZ3RoKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50KSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBwYXRoQXJyYXlbcGF0aExlbmd0aF0gPSBpLnRvU3RyaW5nKClcbiAgICAgICAgICB0cmF2ZXJzZShjdXJyZW50W2ldLCBwYXRoTGVuZ3RoICsgMSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY3VycmVudCA9PT0gJ29iamVjdCcgJiYgY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdXJyZW50KSB7XG4gICAgICAgICAgcGF0aEFycmF5W3BhdGhMZW5ndGhdID0ga2V5XG4gICAgICAgICAgdHJhdmVyc2UoY3VycmVudFtrZXldLCBwYXRoTGVuZ3RoICsgMSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGF0aExlbmd0aCA8IGJlZm9yZVdpbGRjYXJkLmxlbmd0aCkge1xuICAgICAgY29uc3QgbmV4dEtleSA9IGJlZm9yZVdpbGRjYXJkW3BhdGhMZW5ndGhdXG4gICAgICAvLyBUeXBlIHNhZmV0eTogQ2hlY2sgaWYgY3VycmVudCBpcyBhbiBvYmplY3QgYmVmb3JlIHVzaW5nICdpbicgb3BlcmF0b3JcbiAgICAgIGlmIChjdXJyZW50ICYmIHR5cGVvZiBjdXJyZW50ID09PSAnb2JqZWN0JyAmJiBjdXJyZW50ICE9PSBudWxsICYmIG5leHRLZXkgaW4gY3VycmVudCkge1xuICAgICAgICBwYXRoQXJyYXlbcGF0aExlbmd0aF0gPSBuZXh0S2V5XG4gICAgICAgIHRyYXZlcnNlKGN1cnJlbnRbbmV4dEtleV0sIHBhdGhMZW5ndGggKyAxKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDaGVjayBpZiBhZnRlcldpbGRjYXJkIGNvbnRhaW5zIG1vcmUgd2lsZGNhcmRzXG4gICAgICBpZiAoYWZ0ZXJXaWxkY2FyZC5pbmNsdWRlcygnKicpKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGhhbmRsZSByZW1haW5pbmcgd2lsZGNhcmRzXG4gICAgICAgIC8vIFdyYXAgY2Vuc29yIHRvIHByZXBlbmQgY3VycmVudCBwYXRoIGNvbnRleHRcbiAgICAgICAgY29uc3Qgd3JhcHBlZENlbnNvciA9IHR5cGVvZiBjZW5zb3IgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICA/ICh2YWx1ZSwgcGF0aCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IFsuLi5wYXRoQXJyYXkuc2xpY2UoMCwgcGF0aExlbmd0aCksIC4uLnBhdGhdXG4gICAgICAgICAgICAgIHJldHVybiBjZW5zb3IodmFsdWUsIGZ1bGxQYXRoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIDogY2Vuc29yXG4gICAgICAgIHJlZGFjdFdpbGRjYXJkUGF0aChjdXJyZW50LCBhZnRlcldpbGRjYXJkLCB3cmFwcGVkQ2Vuc29yLCBvcmlnaW5hbFBhdGgsIHJlbW92ZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vIG1vcmUgd2lsZGNhcmRzLCBhcHBseSB0aGUgcmVkYWN0aW9uIGRpcmVjdGx5XG4gICAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgICByZW1vdmVLZXkoY3VycmVudCwgYWZ0ZXJXaWxkY2FyZClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBhY3R1YWxDZW5zb3IgPSB0eXBlb2YgY2Vuc29yID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGNlbnNvcihnZXRWYWx1ZShjdXJyZW50LCBhZnRlcldpbGRjYXJkKSwgWy4uLnBhdGhBcnJheS5zbGljZSgwLCBwYXRoTGVuZ3RoKSwgLi4uYWZ0ZXJXaWxkY2FyZF0pXG4gICAgICAgICAgICA6IGNlbnNvclxuICAgICAgICAgIHNldFZhbHVlKGN1cnJlbnQsIGFmdGVyV2lsZGNhcmQsIGFjdHVhbENlbnNvcilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChiZWZvcmVXaWxkY2FyZC5sZW5ndGggPT09IDApIHtcbiAgICB0cmF2ZXJzZShvYmosIDApXG4gIH0gZWxzZSB7XG4gICAgbGV0IGN1cnJlbnQgPSBvYmpcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJlZm9yZVdpbGRjYXJkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJ0ID0gYmVmb3JlV2lsZGNhcmRbaV1cbiAgICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQgPT09IHVuZGVmaW5lZCkgcmV0dXJuXG4gICAgICAvLyBUeXBlIHNhZmV0eTogQ2hlY2sgaWYgY3VycmVudCBpcyBhbiBvYmplY3QgYmVmb3JlIHByb3BlcnR5IGFjY2Vzc1xuICAgICAgaWYgKHR5cGVvZiBjdXJyZW50ICE9PSAnb2JqZWN0JyB8fCBjdXJyZW50ID09PSBudWxsKSByZXR1cm5cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50W3BhcnRdXG4gICAgICBwYXRoQXJyYXlbaV0gPSBwYXJ0XG4gICAgfVxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdHJhdmVyc2UoY3VycmVudCwgYmVmb3JlV2lsZGNhcmQubGVuZ3RoKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZFBhdGhTdHJ1Y3R1cmUgKHBhdGhzVG9DbG9uZSkge1xuICBpZiAocGF0aHNUb0Nsb25lLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsIC8vIE5vIHBhdGhzIHRvIHJlZGFjdFxuICB9XG5cbiAgLy8gUGFyc2UgYWxsIHBhdGhzIGFuZCBvcmdhbml6ZSBieSBkZXB0aFxuICBjb25zdCBwYXRoU3RydWN0dXJlID0gbmV3IE1hcCgpXG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRoc1RvQ2xvbmUpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHBhcnNlUGF0aChwYXRoKVxuICAgIGxldCBjdXJyZW50ID0gcGF0aFN0cnVjdHVyZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0c1tpXVxuICAgICAgaWYgKCFjdXJyZW50LmhhcyhwYXJ0KSkge1xuICAgICAgICBjdXJyZW50LnNldChwYXJ0LCBuZXcgTWFwKCkpXG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5nZXQocGFydClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhdGhTdHJ1Y3R1cmVcbn1cblxuZnVuY3Rpb24gc2VsZWN0aXZlQ2xvbmUgKG9iaiwgcGF0aFN0cnVjdHVyZSkge1xuICBpZiAoIXBhdGhTdHJ1Y3R1cmUpIHtcbiAgICByZXR1cm4gb2JqIC8vIE5vIHBhdGhzIHRvIHJlZGFjdCwgcmV0dXJuIG9yaWdpbmFsXG4gIH1cblxuICBmdW5jdGlvbiBjbG9uZVNlbGVjdGl2ZWx5IChzb3VyY2UsIHBhdGhNYXAsIGRlcHRoID0gMCkge1xuICAgIGlmICghcGF0aE1hcCB8fCBwYXRoTWFwLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBzb3VyY2UgLy8gTm8gbW9yZSBwYXRocyB0byBjbG9uZSwgcmV0dXJuIHJlZmVyZW5jZVxuICAgIH1cblxuICAgIGlmIChzb3VyY2UgPT09IG51bGwgfHwgdHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBzb3VyY2VcbiAgICB9XG5cbiAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKHNvdXJjZS5nZXRUaW1lKCkpXG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgY29uc3QgY2xvbmVkID0gW11cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGluZGV4U3RyID0gaS50b1N0cmluZygpXG4gICAgICAgIGlmIChwYXRoTWFwLmhhcyhpbmRleFN0cikgfHwgcGF0aE1hcC5oYXMoJyonKSkge1xuICAgICAgICAgIGNsb25lZFtpXSA9IGNsb25lU2VsZWN0aXZlbHkoc291cmNlW2ldLCBwYXRoTWFwLmdldChpbmRleFN0cikgfHwgcGF0aE1hcC5nZXQoJyonKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9uZWRbaV0gPSBzb3VyY2VbaV0gLy8gU2hhcmUgcmVmZXJlbmNlIGZvciBub24tcmVkYWN0ZWQgaXRlbXNcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNsb25lZFxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBvYmplY3RzXG4gICAgY29uc3QgY2xvbmVkID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc291cmNlKSlcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIGlmIChwYXRoTWFwLmhhcyhrZXkpIHx8IHBhdGhNYXAuaGFzKCcqJykpIHtcbiAgICAgICAgICBjbG9uZWRba2V5XSA9IGNsb25lU2VsZWN0aXZlbHkoc291cmNlW2tleV0sIHBhdGhNYXAuZ2V0KGtleSkgfHwgcGF0aE1hcC5nZXQoJyonKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9uZWRba2V5XSA9IHNvdXJjZVtrZXldIC8vIFNoYXJlIHJlZmVyZW5jZSBmb3Igbm9uLXJlZGFjdGVkIHByb3BlcnRpZXNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xvbmVkXG4gIH1cblxuICByZXR1cm4gY2xvbmVTZWxlY3RpdmVseShvYmosIHBhdGhTdHJ1Y3R1cmUpXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUGF0aCAocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYXRocyBtdXN0IGJlIChub24tZW1wdHkpIHN0cmluZ3MnKVxuICB9XG5cbiAgaWYgKHBhdGggPT09ICcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlZGFjdGlvbiBwYXRoICgpJylcbiAgfVxuXG4gIC8vIENoZWNrIGZvciBkb3VibGUgZG90c1xuICBpZiAocGF0aC5pbmNsdWRlcygnLi4nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCByZWRhY3Rpb24gcGF0aCAoJHtwYXRofSlgKVxuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIGNvbW1hLXNlcGFyYXRlZCBwYXRocyAoaW52YWxpZCBzeW50YXgpXG4gIGlmIChwYXRoLmluY2x1ZGVzKCcsJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcmVkYWN0aW9uIHBhdGggKCR7cGF0aH0pYClcbiAgfVxuXG4gIC8vIENoZWNrIGZvciB1bm1hdGNoZWQgYnJhY2tldHNcbiAgbGV0IGJyYWNrZXRDb3VudCA9IDBcbiAgbGV0IGluUXVvdGVzID0gZmFsc2VcbiAgbGV0IHF1b3RlQ2hhciA9ICcnXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hhciA9IHBhdGhbaV1cblxuICAgIGlmICgoY2hhciA9PT0gJ1wiJyB8fCBjaGFyID09PSBcIidcIikgJiYgYnJhY2tldENvdW50ID4gMCkge1xuICAgICAgaWYgKCFpblF1b3Rlcykge1xuICAgICAgICBpblF1b3RlcyA9IHRydWVcbiAgICAgICAgcXVvdGVDaGFyID0gY2hhclxuICAgICAgfSBlbHNlIGlmIChjaGFyID09PSBxdW90ZUNoYXIpIHtcbiAgICAgICAgaW5RdW90ZXMgPSBmYWxzZVxuICAgICAgICBxdW90ZUNoYXIgPSAnJ1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJ1snICYmICFpblF1b3Rlcykge1xuICAgICAgYnJhY2tldENvdW50KytcbiAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICddJyAmJiAhaW5RdW90ZXMpIHtcbiAgICAgIGJyYWNrZXRDb3VudC0tXG4gICAgICBpZiAoYnJhY2tldENvdW50IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcmVkYWN0aW9uIHBhdGggKCR7cGF0aH0pYClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYnJhY2tldENvdW50ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJlZGFjdGlvbiBwYXRoICgke3BhdGh9KWApXG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQYXRocyAocGF0aHMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGhzKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhdGhzIG11c3QgYmUgYW4gYXJyYXknKVxuICB9XG5cbiAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgdmFsaWRhdGVQYXRoKHBhdGgpXG4gIH1cbn1cblxuZnVuY3Rpb24gc2xvd1JlZGFjdCAob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBwYXRocyA9IFtdLFxuICAgIGNlbnNvciA9ICdbUkVEQUNURURdJyxcbiAgICBzZXJpYWxpemUgPSBKU09OLnN0cmluZ2lmeSxcbiAgICBzdHJpY3QgPSB0cnVlLFxuICAgIHJlbW92ZSA9IGZhbHNlXG4gIH0gPSBvcHRpb25zXG5cbiAgLy8gVmFsaWRhdGUgcGF0aHMgdXBmcm9udCB0byBtYXRjaCBmYXN0LXJlZGFjdCBiZWhhdmlvclxuICB2YWxpZGF0ZVBhdGhzKHBhdGhzKVxuXG4gIC8vIEJ1aWxkIHBhdGggc3RydWN0dXJlIG9uY2UgZHVyaW5nIHNldHVwLCBub3Qgb24gZXZlcnkgY2FsbFxuICBjb25zdCBwYXRoU3RydWN0dXJlID0gYnVpbGRQYXRoU3RydWN0dXJlKHBhdGhzKVxuXG4gIHJldHVybiBmdW5jdGlvbiByZWRhY3QgKG9iaikge1xuICAgIGlmIChzdHJpY3QgJiYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JykpIHtcbiAgICAgIGlmIChvYmogPT09IG51bGwgfHwgb2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZSA/IHNlcmlhbGl6ZShvYmopIDogb2JqXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZSA/IHNlcmlhbGl6ZShvYmopIDogb2JqXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT25seSBjbG9uZSBwYXRocyB0aGF0IG5lZWQgcmVkYWN0aW9uXG4gICAgY29uc3QgY2xvbmVkID0gc2VsZWN0aXZlQ2xvbmUob2JqLCBwYXRoU3RydWN0dXJlKVxuICAgIGNvbnN0IG9yaWdpbmFsID0gb2JqIC8vIEtlZXAgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIGZvciByZXN0b3JlXG5cbiAgICBsZXQgYWN0dWFsQ2Vuc29yID0gY2Vuc29yXG4gICAgaWYgKHR5cGVvZiBjZW5zb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFjdHVhbENlbnNvciA9IGNlbnNvclxuICAgIH1cblxuICAgIHJlZGFjdFBhdGhzKGNsb25lZCwgcGF0aHMsIGFjdHVhbENlbnNvciwgcmVtb3ZlKVxuXG4gICAgaWYgKHNlcmlhbGl6ZSA9PT0gZmFsc2UpIHtcbiAgICAgIGNsb25lZC5yZXN0b3JlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZGVlcENsb25lKG9yaWdpbmFsKSAvLyBGdWxsIGNsb25lIG9ubHkgd2hlbiByZXN0b3JlIGlzIGNhbGxlZFxuICAgICAgfVxuICAgICAgcmV0dXJuIGNsb25lZFxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc2VyaWFsaXplID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gc2VyaWFsaXplKGNsb25lZClcbiAgICB9XG5cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoY2xvbmVkKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2xvd1JlZGFjdFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pinojs/redact/index.js\n");

/***/ })

};
;